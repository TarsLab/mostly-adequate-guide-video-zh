---
marp: true
theme: uncover
paginate: true
header: '函数式编程指南 第3章：纯函数的好处'
---

![bg right fit](images/cover.png)

第 3 章

《函数式编程指南》

# 纯函数<br/>的好处

---

## 再次强调“纯”

### 纯函数的概念

> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。

---

## 副作用可能包括...

副作用是什么？

> 副作用是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。

---

### 副作用可能包含，但不限于

* 更改文件系统
* 往数据库插入记录
* 发送一个 http 请求
* 修改数据
* 打印/log
* 获取用户输入
* 查询 DOM
* 访问系统状态

---

### 副作用让函数变得不纯

* 纯函数, 相同输入得到相同输出
* 跟外部事物打交道, 无法保证这一点

---

## 高中数学

函数是什么?

> 函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。

---

![bg left fit](images/function-sets.gif)

### 从 x 到 y 的函数关系

$$f(x)=y$$

---

![bg left fit](images/relation-not-function.gif)

### 不是函数关系

* 输入值5指向了多个输出

---

### 函数可以描述为集合映射

`(输入, 输出)对：[(1,2), (3,6), (5,10)]`

| 输入 | 输出 |
| ---  | --- |
| 1    | 2   |
| 2    | 4   |
| 3    | 6   |
| 4    | 8   |
| 5    | 10  |

---

### 函数曲线图

![bg right fit](images/fn_graph.png)

---

* 映射，另外一种思考函数的方式.
* 函数有多个参数呢？后面的第4章柯里化会讲到
* 纯函数就是数学上的函数，而且是整个函数式编程的理论基础

---

## 追求“纯”的理由

---

### 1. 可缓存性（Cacheable）

纯函数总能够根据输入来做缓存

---

### 2. 可移植性／自文档化（Portable / Self-Documenting）

* 纯函数的依赖很明确，更易于观察和理解
* 通过强迫“注入”依赖，或者把它们当作参数传递，应用也更加灵活
* 你上一次把某个类方法拷贝到新的应用中是什么时候？

---

> 面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩...以及整个丛林

---

### 3. 可测试性（Testable）

* 只需简单地给函数一个输入，然后断言输出就好了
* 函数式编程的社区在开创一些新的测试工具

---

### 4. 合理性（Reasonable）

> 如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。

* 引用透明性（referential transparency）
* 等式推导带来分析代码的能力, 有利于重构

---

### 5. 并行代码（Parallel code）

* 可以并行运行任意纯函数
* 纯函数不会因副作用而进入竞争态（race condition）

---

## 总结

1) 可缓存性（Cacheable）
2) 可移植性/自文档化（Portable / Self-Documenting）
3) 可测试性（Testable）
4) 合理性（Reasonable）
5) 并行代码（Parallel code）
